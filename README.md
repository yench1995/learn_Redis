# learn_Redis

##  Data structure
---
#### 简单动态字符串 (simple dynamic string, sds)
Redis没有直接诶使用C语言传统的字符串表示(以空字符结尾的字符数组），而是构建了SDS作为底层字符串数据结构的实现。结构的定义和接口方式实现在__sds.h__和__sds.c__中。  
除了用来保存数据库中的字符串值之后，SDS还被用作缓冲区：AOF模块中的AOF缓冲区，以及客户端状态中的输入缓冲区。  
SDS相较于普通C字符串的优势在于：
+ O(1)时间复杂度获取字符串的长度
+ API是安全的，不会造成缓冲区溢出
+ 修改字符串长度N次最多需要执行N次内存重分配(因为有free区惰性释放）
+ 可以保存文本或者二进制数据(而C字符串只能保存文本数据）
+ 可以使用一部分<string.h>库中的函数（API返回的一般都是指向buf区的指针）  

#### 链表 (linkedlist)
链表提供了高效的节点重排能力，以及顺序性的节点访问方式，并且可以通过增删节点来灵活地调整链表的长度。链表使用双端链表来实现，
定义在__adlist.h__和__adlist.c__中。  
链表在Redis中的应用十分广泛，如链列表键的底层实现之一就是链表，发布与订阅，慢查询，监视器等功能。  
Redis的链表实现的特性可以总结如下:
+ 双端：链表节点带有prev和next指针，获取某个节点的前置节点和后置节点的复杂度都是O(1)。
+ 无环：表头节点的prev指针和表尾节点的next指针都指向NULL，对链表的访问以NULL为终点。
+ 带表头指针和表尾指针：通过list结构的head指针和tail指针，程序获取链表的表头节点和表尾节点
的复杂为O(1)。
+ 多态：链表节点使用void*指针来保存节点值，并且可以通过list结构的dup,free,match三个属性为节点值设置类型特定函数
所以链表可以用于保存各种不同类型的值。


#### 字典 (dictionary)
字典是一种用于保存键值对(key-value pair)的抽象数据结构。字典被广泛用于实现Redis的各种功能，其中包括数据库和哈希键。
定义在__dict.h__和__dict.c__中。
Redis的字典特性：
+ Redis中的字典使用哈希表作为底层实现，每个字典带有两个哈希表，一个平时使用，另一个仅在进行rehash时使用。
+ 当字典被用作数据库的底层实现，或者哈希键的底层实现时，Redis使用MurmurHash2算法来计算键的哈希值。
+ 哈希表使用链接地址发来解决键冲突，被分配到同一个索引上的多个键值对会连接成一个单向链表，总是将新加入的节点排在最前。
+ 在对哈希表进行扩展或者收缩操作时，程序需要将现有哈希表包含的所有键值对rehash到新哈希表中，这个rehash过程是
渐进式完成的，分散在每一次增删改查操作中。


#### 跳跃表 (skiplist)
跳跃表是一种有序数据结构，它通过在每个节点中维持多个指向其他节点的指针，从而达到快速访问节点的目的。定义在redis.h文件中。  
跳跃表的特性：
+ 跳跃表是有序集合的底层实现之一。
+ Redis的跳跃表实现由zskiplist和zskiplistNode两个结构组成，其中zskiplist用于保存跳跃表信息(比如表头节点，表尾节点，长度）,
而zskiplistNode则用于表示跳跃表节点。
+ 每个跳跃表节点的层高都是1-32之间的随机数。
+ 在同一个跳跃表中，多个节点可以包含相同的分值，但每个节点的成员对象必须是唯一的。
+ 跳跃表中的节点按照分值大小进行排序，当分值相同时，节点按照成员对象的大小进行排序。

#### 整数集合 (intset)
整数集合是Redis用于保存整数值的集合抽象数据结构，它可以保存类型为int16_t,int32_t或者int64_t的整数值
并且保证集合中不会出现重复元素。定义在__intset.h__和__intset.c__中。  
整数集合的特性：
+ 整数集合的底层实现为数组，这个数组以有序，无重复的方式保存集合元素，在有需要时，程序会根据新添加元素的类型，
彻底改变这个数组的类型。
+ 升级操作为整数集合带来了操作上的灵活性，并尽可能地节约了内存。
+ 整数集合只支持升级操作，不支持降级操作。

#### 压缩列表 (ziplist)
当一个列表键只包含少量列表项，或者哈希键只包含少量键值对时，压缩列表会作为底层的实现。压缩列表是Redis为了节约内存而
开发的，是由一系列特殊编码的连续内存块组成的顺序型数据结构。一个压缩列表可以包含任意多个节点，每个节点可以保存一个
字节数组或者一个整数值。定义在__ziplist.c__和ziplist.h__中。  
当压缩列表更新其中一个节点时，会引发后面节点的previous_entry_length编码大小的更新。但这种连锁更新出现的几率并不高。  

---
## 对象
Redis并没有直接使用前面介绍的数据结构来实现键值对数据库，而是基于这些数据结构创建了一个对象系统，这个系统包含了
字符串对象、列表对象、哈希对象、集合对象、和有序集合对象这五种类型。定义在__object.c__中。  
因为Redis数据库的键总是字符串对象，所以称呼“列表键”意味着这个数据库键对应的值为列表对象。  

| 类型 | 编码 | 对象 |  
| --- | --- | --- |
|REDIS_STRING|REDIS_ENCODING_INT|使用整数值实现的字符串对象|
|REDIS_STRING|REDIS_ENCODING_EMBSTR|使用embstr编码的简单动态字符串实现的字符串对象|
|REDIS_STRING|REDIS_ENCODING_RAW|使用简单动态字符串实现的字符串对象|
|REDIS_LIST|REDIS_ENCODING_ZIPLIST|使用压缩列表实现的列表对象|
|REDIS_LIST|REDIS_ENCODING_LINKEDLIST|使用双端链表实现的列表对象|
|REDIS_HASH|REDIS_ENCODING_ZIPLIST|使用压缩列表实现的哈希对象|
|REDIS_HASH|REDIS_ENCODING_HT|使用字典实现的哈希对象|
|REDIS_SET|REDIS_ENCODING_INTSET|使用整数集合实现的集合对象|
|REDIS_SET|REDIS_ENCODING_HT|使用字典实现的集合对象|
|REDIS_ZSET|REDIS_ENCODING_ZIPLIST|使用压缩列表实现的有序集合对象|
|REDIS_ZSET|REDIS_ENCODING_SKIPLIST|使用跳跃和字典实现的有序集合对象|

对象的特性：
+ 字符串、列表、哈希、集合、有序集合这五种不同类型的对象每种至少都有两种以上或以上的编码方式，
不同的编码可以在不同的使用场景上优化对象的使用效率。
+ embstr编码是专门用于保存短字符串的一种优化编码方式，它和raw编码一样使用redisObject结构和sdshdr结构，
但embstr只调用一次内存分配函数来将redisObject和sdshdr结构分配在一块连续的空间内。
+ ZIPLIST的底层实现一般都用于字符串元素少和长度较短的情况下，不满足情况的条件下会进行编码转换成另一种数据结构。
+ 有序集合使用dict和skiplist实现是因为dict可以通过O(1)时间查找给定对象的分值，而skiplist通过O(logN)时间执行范围操作，
而且两种数据结构都会通过指针来共享相同元素的成员和分值，不会造成额外的内存浪费。
+ REDIS的对象系统可以方便地处理多态命令，如DEL等命令是基于类型的多态，一个命令可以同时用于处理多种不同类型的键；
而LLEN等命令是基于编码的多态，一个命令可以同时用于处理多种不同编码。服务器在执行命令之前，会先检查给定键的类型能否执行指定的命令，
而检查一个键的类型就是检查键的值的类型。
+ Redis的对象系统带有引用计数实现的内存回收机制，当一个对象不再被使用时，该对象所占用的内存就会被自动释放。
+ Redis在启动时会创建0-9999的字符串对象，当需要使用时会共享。
+ 对象会记录子集的最后一次被访问的时间，这个时间可以用于计算对象的空转时间。
