# learn_Redis

##  Data structure
---
#### 简单动态字符串 (simple dynamic string, sds)
Redis没有直接诶使用C语言传统的字符串表示(以空字符结尾的字符数组），而是构建了SDS作为底层字符串数据结构的实现。结构的定义和接口方式实现在__sds.h__和__sds.c__中。  
除了用来保存数据库中的字符串值之后，SDS还被用作缓冲区：AOF模块中的AOF缓冲区，以及客户端状态中的输入缓冲区。  
SDS相较于普通C字符串的优势在于：
+ O(1)时间复杂度获取字符串的长度
+ API是安全的，不会造成缓冲区溢出
+ 修改字符串长度N次最多需要执行N次内存重分配(因为有free区惰性释放）
+ 可以保存文本或者二进制数据(而C字符串只能保存文本数据）
+ 可以使用一部分<string.h>库中的函数（API返回的一般都是指向buf区的指针）  

#### 链表 (linkedlist)
链表提供了高效的节点重排能力，以及顺序性的节点访问方式，并且可以通过增删节点来灵活地调整链表的长度。链表使用双端链表来实现，
定义在__adlist.h__和__adlist.c__中。  
链表在Redis中的应用十分广泛，如链列表键的底层实现之一就是链表，发布与订阅，慢查询，监视器等功能。  
Redis的链表实现的特性可以总结如下:
+ 双端：链表节点带有prev和next指针，获取某个节点的前置节点和后置节点的复杂度都是O(1)。
+ 无环：表头节点的prev指针和表尾节点的next指针都指向NULL，对链表的访问以NULL为终点。
+ 带表头指针和表尾指针：通过list结构的head指针和tail指针，程序获取链表的表头节点和表尾节点
的复杂为O(1)。
+ 多态：链表节点使用void*指针来保存节点值，并且可以通过list结构的dup,free,match三个属性为节点值设置类型特定函数
所以链表可以用于保存各种不同类型的值。


#### 字典 (dictionary)
字典是一种用于保存键值对(key-value pair)的抽象数据结构。字典被广泛用于实现Redis的各种功能，其中包括数据库和哈希键。
定义在__dict.h__和__dict.c__中。
Redis的字典特性：
+ Redis中的字典使用哈希表作为底层实现，每个字典带有两个哈希表，一个平时使用，另一个仅在进行rehash时使用。
+ 当字典被用作数据库的底层实现，或者哈希键的底层实现时，Redis使用MurmurHash2算法来计算键的哈希值。
+ 哈希表使用链接地址发来解决键冲突，被分配到同一个索引上的多个键值对会连接成一个单向链表，总是将新加入的节点排在最前。
+ 在对哈希表进行扩展或者收缩操作时，程序需要将现有哈希表包含的所有键值对rehash到新哈希表中，这个rehash过程是
渐进式完成的，分散在每一次增删改查操作中。


#### 跳跃表 (skiplist)
跳跃表是一种有序数据结构，它通过在每个节点中维持多个指向其他节点的指针，从而达到快速访问节点的目的。定义在redis.h文件中。  
跳跃表的特性：
+ 跳跃表是有序集合的底层实现之一。
+ Redis的跳跃表实现由zskiplist和zskiplistNode两个结构组成，其中zskiplist用于保存跳跃表信息(比如表头节点，表尾节点，长度）,
而zskiplistNode则用于表示跳跃表节点。
+ 每个跳跃表节点的层高都是1-32之间的随机数。
+ 在同一个跳跃表中，多个节点可以包含相同的分值，但每个节点的成员对象必须是唯一的。
+ 跳跃表中的节点按照分值大小进行排序，当分值相同时，节点按照成员对象的大小进行排序。

#### 整数集合 (intset)
整数集合是Redis用于保存整数值的集合抽象数据结构，它可以保存类型为int16_t,int32_t或者int64_t的整数值
并且保证集合中不会出现重复元素。定义在__intset.h__和__intset.c__中。  
整数集合的特性：
+ 整数集合的底层实现为数组，这个数组以有序，无重复的方式保存集合元素，在有需要时，程序会根据新添加元素的类型，
彻底改变这个数组的类型。
+ 升级操作为整数集合带来了操作上的灵活性，并尽可能地节约了内存。
+ 整数集合只支持升级操作，不支持降级操作。

#### 压缩列表 (ziplist)
当一个列表键只包含少量列表项，或者哈希键只包含少量键值对时，压缩列表会作为底层的实现。压缩列表是Redis为了节约内存而
开发的，是由一系列特殊编码的连续内存块组成的顺序型数据结构。一个压缩列表可以包含任意多个节点，每个节点可以保存一个
字节数组或者一个整数值。定义在__ziplist.c__和ziplist.h__中。  
当压缩列表更新其中一个节点时，会引发后面节点的previous_entry_length编码大小的更新。但这种连锁更新出现的几率并不高。  

---
## 对象系统
Redis并没有直接使用前面介绍的数据结构来实现键值对数据库，而是基于这些数据结构创建了一个对象系统，这个系统包含了
字符串对象、列表对象、哈希对象、集合对象、和有序集合对象这五种类型。定义在__object.c__中。  
因为Redis数据库的键总是字符串对象，所以称呼“列表键”意味着这个数据库键对应的值为列表对象。  

| 类型 | 编码 | 对象 |  
| --- | --- | --- |
|REDIS_STRING|REDIS_ENCODING_INT|使用整数值实现的字符串对象|
|REDIS_STRING|REDIS_ENCODING_EMBSTR|使用embstr编码的简单动态字符串实现的字符串对象|
|REDIS_STRING|REDIS_ENCODING_RAW|使用简单动态字符串实现的字符串对象|
|REDIS_LIST|REDIS_ENCODING_ZIPLIST|使用压缩列表实现的列表对象|
|REDIS_LIST|REDIS_ENCODING_LINKEDLIST|使用双端链表实现的列表对象|
|REDIS_HASH|REDIS_ENCODING_ZIPLIST|使用压缩列表实现的哈希对象|
|REDIS_HASH|REDIS_ENCODING_HT|使用字典实现的哈希对象|
|REDIS_SET|REDIS_ENCODING_INTSET|使用整数集合实现的集合对象|
|REDIS_SET|REDIS_ENCODING_HT|使用字典实现的集合对象|
|REDIS_ZSET|REDIS_ENCODING_ZIPLIST|使用压缩列表实现的有序集合对象|
|REDIS_ZSET|REDIS_ENCODING_SKIPLIST|使用跳跃和字典实现的有序集合对象|  
  
  
  

__对象的特性__
+ 字符串、列表、哈希、集合、有序集合这五种不同类型的对象每种至少都有两种以上或以上的编码方式，
不同的编码可以在不同的使用场景上优化对象的使用效率。
+ embstr编码是专门用于保存短字符串的一种优化编码方式，它和raw编码一样使用redisObject结构和sdshdr结构，
但embstr只调用一次内存分配函数来将redisObject和sdshdr结构分配在一块连续的空间内。
+ ZIPLIST的底层实现一般都用于字符串元素少和长度较短的情况下，不满足情况的条件下会进行编码转换成另一种数据结构。
+ 有序集合使用dict和skiplist实现是因为dict可以通过O(1)时间查找给定对象的分值，而skiplist通过O(logN)时间执行范围操作，
而且两种数据结构都会通过指针来共享相同元素的成员和分值，不会造成额外的内存浪费。
+ Redis的对象系统可以方便地处理多态命令，如DEL等命令是基于类型的多态，一个命令可以同时用于处理多种不同类型的键；
而LLEN等命令是基于编码的多态，一个命令可以同时用于处理多种不同编码。服务器在执行命令之前，会先检查给定键的类型能否执行指定的命令，
而检查一个键的类型就是检查键的值的类型。
+ Redis的对象系统带有引用计数实现的内存回收机制，当一个对象不再被使用时，该对象所占用的内存就会被自动释放。
+ Redis在启动时会创建0-9999的字符串对象，当需要使用时会共享。
+ 对象会记录子集的最后一次被访问的时间，这个时间可以用于计算对象的空转时间。

__类型系统总结__  

Redis作为一款内存数据库软件，它需要最大程度的减少内存的开销。对于这五种类型的底层数据结构的多种编码实现，redis都充分考虑了内存消耗和时间复杂度的平衡，目的是在一定可控的时间复杂读条件下尽可能的减少不必要的内存开销，从而达到节省内存的效果。一般来说，底层编码会设定一个阈值，当当前结构保存的元素的数量或者长度超过一定阈值后，底层会自动转换成另一种编码方式来平衡时间复杂度。如哈希对象的底层实现可以是ziplist和hashtable，ziplist紧凑的编码可以最大程度的较少内存的开销，还将数据存于连续的内存区域，能更好的利用缓存的优势，减少了内存碎片。但压缩列表的新增、删除操作的平均时间复杂度为O(N)(因为可能需要realloc重新分配内存，并且连锁更新可能导致O(N2)的时间复杂度)。而hashtable可以以常数时间新增和删除新的节点。在一定N内的时间复杂度内拿时间换空间是值得的，但超过一定阈值后，就需要采用另一种编码。


## RDB与AOF持久化
Redis是内存数据库，一旦服务器进程退出，服务器中的数据库状态也会消失不见。因此，Redis
提供了RDB持久化功能和AOF持久化功能，来将Redis在内存中的数据状态保存到磁盘里面，避免
数据意外丢失。   

#### RDB
RDB持久化功能是将服务器在某个时间点上的数据库状态保存到一个压缩的二进制RDB文件中，通过该
文件可以还原生成RDB文件时的数据库状态。SAVE命令会阻塞服务器进程，直到RDB文件创建完成，而
BGSAVE命令会派生出一个子进程进行创建RDB文件，然后父进程继续处理命令请求。   

服务器中会保存所有用save选项设置的保存条件，当任意一个保存条件(包括dirty和save_interval)被满足时，服务器会自动
执行BGSAVE命令。    

一个完整RDB文件包含<REDIS><db_version><database><EOF><check_sum>五部分，其中<database>
部分由三部分组成，<SELECTDB><db_number><key_value_pairs>，每个<key_value_pairs>
部分保存了一定数量的键值对，如果键值对带有过期时间，过期时间也会被保存。不对的值由不同的
type指定，其内容包含<TYPE><key><value>，value的编码详见'src/rdb.c'文件。
  
  
#### AOF
AOF(Append only file)持久化通过保存Redis服务器所执行的写命令来记录数据库状态。被写入AOF文件的
所有__命令请求协议都是纯文本格式__。  
AOF持久化功能的实现可以分为__命令追加、文件写入、文件同步__三个步骤
+ 命令追加(append):当AOF持久化功能处于打开状态时，服务器在执行完一个写命令之后，会以
协议格式将被执行的写命令追加到服务器状态的aof_buf缓冲区的末尾
+ 文件的写入和同步：在服务器每次结束一个事件循环之前，它都会调用flushAppendOnlyFile函数
，考虑是否需要将aof_buf缓冲区中的内容写入和保存到AOF文件里。  

Redis读取并还原数据库状态的详细步骤如下：
1. __创建一个不带网络连接的伪客户端__(fake client)：因为Redis的命令只能在客户端的上下文中执行
而载入AOF文件时所使用的命令直接来源于AOF文件而不是网络连接。
2. 从AOF文件中分析并读取一条写命令，并使用伪客户端执行被读出的写命令。
3. 重复执行2步骤，直到AOF文件中的所有写命令都被处理完毕。  

AOF文件重写功能将生成新的AOF文件替代旧AOF文件，来减少其因为不断追加命令而不断变大的文件体积。
AOF文件重写功能创建一个子进程在后台运行，读取服务器数据库的状态，用最少的命令来执行添加操作。同时，
rewrite过程中的服务器主进程接收到的客户端命令，将被同时写到AOF缓冲区和AOF重写缓冲区内。当子进程完成
AOF重写后，将会向父进程发送完成信号。父进程接收到信号后，将AOF重写缓冲区中的所有内容写入新AOF文件
中，对新AOF文件进行改名，原子地覆盖现有的AOF文件。

## 事件
Redis服务器是一个事件驱动程序，主要处理以下两类事件：
+ 文件事件(file event):Redis服务器通过套接字与客户端进行连接，文件事件就是服务器对套接字操作
的抽象。服务器与客户端的通信会产生相应的文件事件，而服务器则通过监听并处理这些事件
来完成一系列网络通信操作。
+ 时间时间(time event):Redis中的一些操作(比如serverCron)需要在给定的时间点执行，而时间
时间就是服务器对这类定时操作的抽象。  

文件事件处理器由四个部分组成，套接字、IO多路复用程序、文件事件分派器
和事件处理器。多个并发事件会被放在一个队列里面，然后通过队列以有序的方式向
文件事件分派器传送套接字。  
时间事件分为定时事件和周期性事件：定时事件只在指定的时间到达一次，而周期性事件则每隔一段时间
到达一次。服务器在一般情况下只执行serverCron函数一个时间事件。
